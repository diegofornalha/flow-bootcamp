# 

Voc√™ aprendeu o que √© o fluxo. Voc√™ conhece Cadence e entende o que √© um recurso. Seu ambiente est√° pronto para tir√°-lo do host local.

### üëÅUm contrato real da NFT

Hora de fazer um contrato NFT adequado. Como voc√™ notou, nosso contrato atual com a NFT apenas deixa em branco as NFTs. Tamb√©m n√£o h√° fun√ß√£o de hortel√£, ent√£o ningu√©m mais pode obter NFTs lol

Aqui est√° o que um contrato NFT com recursos b√°sicos como:

`pub contract BottomShot {
  // This is a simple NFT mint counter
  pub var totalSupply: UInt64
  
  pub resource NFT {
    // The unique ID that differentiates each NFT
    pub let id: UInt64

    // We set the ID of the NFT and update the NFT counter
    init() {
        self.id = BottomShot.totalSupply
        // totalSupply is a global variable for this contract
        BottomShot.totalSupply = BottomShot.totalSupply + (1 as UInt64)
    }
  }
  
  // This is a resource that's going to contain all the NFTs any one account owns
  pub resource Collection {
    // This is a dictionary that maps ID integers with NFT resources
    // the @ indicates that we're working with a resource
    pub var ownedNFTs: @{UInt64: NFT}

    // This function will deposit an NFT into the collection
    // Takes in a variable called token of type NFT that's a resource
    pub fun deposit(token: @NFT) {
      // Move the NFT into the ownedNFTs dictionary
      // <-! is the force-assignment operator
      self.ownedNFTs[token.id] <-! token
    }

    pub fun withdraw(id: UInt64): @NFT {
      // We pull out the NFT resource from the dictionary 
      let token <- self.ownedNFTs.remove(key: id) ??
        panic("This collection doesn't contain an NFT with that id")
      
      return <- token
    }
    
    // Returns an array of integers
    pub fun getIDs(): [UInt64] {
      // The keys in the ownedNFTs dictionary are the IDs
      return self.ownedNFTs.keys
    }

    init() {
      // All resource values MUST be initiated so we make it empty!
      self.ownedNFTs <- {}
    }
  
    // This burns the ENTIRE collection (i.e. every NFT the user owns) 
    destroy () {
      destroy self.ownedNFTs
    }
  }

  pub fun createCollection(): @Collection {
    return <- create Collection()
  }

  pub fun mintNFT(): @NFT {
    return <- create NFT()
  } 

  init() {
    self.totalSupply = 0
  }
}`

N√£o fique sobrecarregado! Este √© o momento em que voc√™ percebe como¬†**f√°cil**¬†Cad√™ncia √©.

Eu deixei um monte de coment√°rios.¬†**Leia-os.**¬†Ent√£o certifique-se de ler o c√≥digo, ele quase se explica!

Para as partes que n√£o se explicam, voc√™ me pegou < 3

Come√ßando do topo:

  `// This is a simple NFT mint counter
  pub var totalSupply: UInt64
  
  pub resource NFT {
    // The unique ID that differentiates each NFT
    pub let id: UInt64

    // We set the ID of the NFT and update the NFT counter
    init() {
        self.id = BottomShot.totalSupply
        // totalSupply is a global variable for this contract
        BottomShot.totalSupply = BottomShot.totalSupply + (1 as UInt64)
    }
  }`

Nossa defini√ß√£o de recurso NFT √© um pouco diferente: precisamos apenas do ID NFT aqui. Lembre-se, a fun√ß√£o init √© executada toda vez que um recurso √© criado. Nele, definimos o ID para a NFT criada e atualizamos o contador global. Isso garante que cada NFT tenha um ID exclusivo para que possamos us√°-los para identifica√ß√£o!

Logo depois disso, voc√™ tem um¬†`Collection`¬†recurso. Pense em quando voc√™ era crian√ßa. Voc√™ tinha uma cole√ß√£o de cart√µes Pokemon? Talvez voc√™ tenha colecionado bolinhas de gude, moedas ou selos? Ou talvez eu seja um boomer e as crian√ßas colecionem peles de Fortnite hoje em dia. O que quer que voc√™ tenha coletado, voc√™ provavelmente manteve todos eles¬†*no mesmo lugar*¬†( ou mesma conta Fortnite lol ). Isso facilitou muito o controle deles.

Estamos fazendo a mesma coisa em Cadence. Uma cole√ß√£o √© um recurso que possui todas as nossas NFTs. Isso facilita o armazenamento de +. Cada conta que quiser cunhar uma NFT precisar√° primeiro fazer uma cole√ß√£o.

A nova sintaxe que vemos no recurso de cole√ß√£o:

`pub var ownedNFTs: @{UInt64: NFT}`

[Dicion√°rios](https://docs.onflow.org/cadence/tutorial/04-non-fungible-tokens/#dictionaries): Estes s√£o como mapeamentos!

`self.ownedNFTs[token.id] <-! token`

[Operador de atribui√ß√£o de for√ßa](https://docs.onflow.org/cadence/language/values-and-types/#force-assignment-operator--): Isso atribui um recurso a uma vari√°vel se a vari√°vel for nula. Se a vari√°vel n√£o for nula, a execu√ß√£o ser√° interrompida lol

### ‚Åá ‚ôÇÔ∏èExecute e interaja com nosso contrato

Vamos apenas usar a extens√£o para implantar nossos contratos localmente a partir de agora. Voc√™ pode usar o¬†[Comandos CLI](https://docs.onflow.org/flow-cli/account-update-contract/)¬†se voc√™ quiser, mas vou ficar com a extens√£o para manter as coisas consistentes.

Basta clicar no link / bot√£o "Implantar contrato" na parte superior do arquivo:

[https://camo.githubusercontent.com/a0881ca6ce985e4c3fe0aa4179be2923ff4c989906c5af5ce0ffc1fbdfa047d5/68747470733a2f2f6861636b6d642e696f2f5f75706c6f6164732f5331324249434b74712e706e67](https://camo.githubusercontent.com/a0881ca6ce985e4c3fe0aa4179be2923ff4c989906c5af5ce0ffc1fbdfa047d5/68747470733a2f2f6861636b6d642e696f2f5f75706c6f6164732f5331324249434b74712e706e67)

Para interagir com o nosso contrato, vamos escrever uma transa√ß√£o. Fa√ßa um¬†`transactions`¬†pasta na raiz do seu projeto e adicione um arquivo chamado¬†`createCollection.cdc`:

`import BottomShot from 0xf8d6e0586b0a20c7

transaction {
  
  prepare(acct: AuthAccount) {
    acct.save(<- BottomShot.createCollection(), to: /storage/BottomShot)
  }

  execute {
    log("Stored a collection for our NUTTY empty NFTs")
  }
}`

Esta transa√ß√£o chama o¬†`createCollection`¬†fun√ß√£o e armazena no¬†`BottomShot`¬†dom√≠nio em nosso contrato.

Novamente, para executar isso, basta clicar no prompt na parte superior do arquivo, para transa√ß√µes que diz "Enviar assinado pela ServiceAccount"

[https://camo.githubusercontent.com/87784e18293769a6922f885ecd3384394d64195c0d9565392cf4cc7a4162a7fd/68747470733a2f2f6861636b6d642e696f2f5f75706c6f6164732f426b6f75384a6346712e706e67](https://camo.githubusercontent.com/87784e18293769a6922f885ecd3384394d64195c0d9565392cf4cc7a4162a7fd/68747470733a2f2f6861636b6d642e696f2f5f75706c6f6164732f426b6f75384a6346712e706e67)

ServiceAccount √© a conta padr√£o com a qual voc√™ est√° conectado no emulador. Voc√™ ver√° os logs impressos no terminal executando o emulador:

[https://camo.githubusercontent.com/514fcb48732e2f4b458f3d92ea41a9fc8b9a0b5845576321f74149ee60605585/68747470733a2f2f6861636b6d642e696f2f5f75706c6f6164732f5379584d346b3546632e706e67](https://camo.githubusercontent.com/514fcb48732e2f4b458f3d92ea41a9fc8b9a0b5845576321f74149ee60605585/68747470733a2f2f6861636b6d642e696f2f5f75706c6f6164732f5379584d346b3546632e706e67)

Agrad√°vel! Acabamos de executar uma transa√ß√£o localmente e interagimos com nosso contrato no emulador!

Vamos cunhar uma NFT e adicion√°-la a esta cole√ß√£o! Crie outro arquivo na sua pasta de transa√ß√µes chamada¬†`depositNFT.cdc`:

`import BottomShot from 0xf8d6e0586b0a20c7

transaction {
  
  prepare(acct: AuthAccount) {
    let collectionReference = 
      acct.borrow<&BottomShot.Collection>(from: /storage/BottomShot)
      ?? panic("No collection found!")

    collectionReference.deposit(token: <- BottomShot.mintNFT())
  }

  execute {
    log("Minted an NFT and stored it into the collection")
  }
}`

Aqui estamos vendo algo novo:¬†`borrow`.

Lembra como eu disse que os recursos s√≥ podem existir em um lugar ao mesmo tempo? Isso tamb√©m significa que voc√™ n√£o pode executar fun√ß√µes ou acessar coisas dentro desses recursos.

Portanto, nesta transa√ß√£o, emprestamos o recurso de coleta do local em que est√° armazenado (`/storage/BottomShot`). Isso nos d√° um tempor√°rio¬†*refer√™ncia*¬†ao recurso ( se tivermos acesso a ele ), para que possamos fazer altera√ß√µes nele. Quando a transa√ß√£o termina, o recurso √© retornado automaticamente.

Usamos a refer√™ncia para chamar de¬†`deposit`¬†fun√ß√£o e passe no recurso NFT retornado pela fun√ß√£o de hortel√£.

O¬†`?`¬†est√° indicando que o valor antes de ser um¬†[opcional](https://docs.onflow.org/cadence/language/values-and-types/#optionals)¬†- pode ter um valor ou pode ser¬†`nil`, significando nada.¬†`??`¬†√© para uma op√ß√£o dupla, o que significa que pode ter um valor opcional ou pode ser¬†`nil`. Se a fun√ß√£o de empr√©stimo n√£o devolver nada, n√≥s¬†`[panic](https://docs.onflow.org/cadence/language/built-in-functions/#panic)`, que encerra a transa√ß√£o com o erro.

LETSSS GOOOOO N√ìS ESTAMOS BALLIN NOSSA CONTA TEM UMA COLE√á√ÉO¬†**E**¬†UM NFT DENTRO!!!

### üòØRecursos e scripts

H√° um grande problema com o nosso contrato agora. N√£o h√° como os outros descobrirem quais NFTs possuo no armazenamento de contratos. Isso √© porque o¬†`getIDs`¬†fun√ß√£o √©¬†*por dentro*¬†o recurso Cole√ß√£o e acess√≠vel apenas pela minha conta. Isso significa que voc√™ teria que doar sua NFT a algu√©m para deix√°-lo ver o que √©. Caramba.

Volte ao seu contrato, adicionaremos uma interface que resolver√° isso. Adicione o¬†`CollectionPublic`¬†recurso na linha 16, logo ap√≥s onde voc√™ declara o recurso NFT:

  `// This interface exposes only the getIDs function
  pub resource interface CollectionPublic {
    pub fun getIDs(): [UInt64]
  }
  
  // Update the Collection resource declaration to implement the new interface
  pub resource Collection: CollectionPublic {
    // The rest of your contract REMAINS THE SAME`

Parece meio estranho, n√£o √©? Como adicionar essa interface para uma fun√ß√£o que j√° t√≠nhamos resolve alguma coisa? AHA! Voc√™ caiu na minha armadilha. Ao fazer voc√™ fazer algo aparentemente in√∫til, investi voc√™ no que vem a seguir.

Cadence tem esse nome "[Controle de acesso baseado em capacidade](https://docs.onflow.org/cadence/language/capability-based-access-control/)" coisa. O que nos permite fazer √© criar um¬†**capacidade**¬†que fornece aos usu√°rios espec√≠ficos acesso a determinados campos ou fun√ß√µes de um objeto armazenado.

Pense nisso como uma chave que desbloqueia uma parte espec√≠fica do seu cofre. Voc√™ pode colocar essa chave em algum lugar ( sob o seu capacho, por exemplo ) e quem sabe sobre a chave tem a capacidade de acessar o objeto. Eles podem buscar a chave e abrir o cofre.

**Nota**¬†Lembre-se de reimplementar seu contrato aqui! Voc√™ pode fazer isso clicando em implantar na parte superior do arquivo.

Agora que temos uma interface que exp√µe a √∫nica fun√ß√£o que queremos que as pessoas tenham, daremos a todos o¬†*capacidade*¬†para chamar essa fun√ß√£o.

Abra seu¬†`createCollection.cdc`¬†transaction e atualize-o para isso:

`import BottomShot from 0xf8d6e0586b0a20c7

transaction {
  
  prepare(acct: AuthAccount) {
                                                // I changed the storage address here
    acct.save(<- BottomShot.createCollection(), to: /storage/BottomShot2)
    
    // We're linking two resources in different storage domains
    acct.link<&BottomShot.Collection{BottomShot.CollectionPublic}>
      (/public/BottomShot2, target: /storage/BottomShot2)
  }
  
  execute {
    log("Stored a collection for our NUTTY empty NFTs")
  }
}`

Eu fiz duas mudan√ßas aqui.

Primeiro: mudei o caminho ( / armazenamento / BottomShot2 ) no qual estamos armazenando nossa cole√ß√£o. Isso ocorre porque voc√™ n√£o pode substituir o armazenamento no Flow ( imagine acidentalmente substituir um CryptoPunk¬†üíÄ) e se voc√™ n√£o fechou o emulador desde a √∫ltima vez que fez uma cole√ß√£o, esse caminho ser√° seguido.

A grande mudan√ßa aqui √© a¬†`link`¬†chamada de fun√ß√£o. A cole√ß√£o existe no¬†`/storage/`¬†dom√≠nio. Estamos vinculando ao¬†`/public/`¬†dom√≠nio. Lembrete: / armazenamento s√≥ pode ser acessado pelo propriet√°rio da conta. / p√∫blico √© acess√≠vel por qualquer pessoa.

Reparti√ß√£o da sintaxe:

- `acct.link`
    
    : conta com a qual estamos trabalhando e a fun√ß√£o que estamos chamando
    
- `<&BottomShot.Collection{BottomShot.CollectionPublic}>link`
    
    : Este √© o tipo nosso
    
    fun√ß√£o espera - uma refer√™ncia ( & ) ao recurso CollectionPublic na cole√ß√£o de contratos BottomShot
    
- `(/public/BottomShot2, target: /storage/BottomShot2)`
    
    : Os dois caminhos que estamos vinculando
    

Coloque outra maneira:

`account.function<&Contract.Resource{Contract.Interface}>(destinationPath, sourcePath)`

Clique em "Enviar assinado" na parte superior do arquivo da transa√ß√£o para execut√°-lo. Atualizar o¬†`depositNFT.cdc`¬†transa√ß√£o com o novo caminho ( "BottomShot2" ) e execute-o tamb√©m.

Agora temos um novo contrato, uma nova cole√ß√£o e uma nova NFT. Vamos escrever um script para l√™-los!

Crie uma pasta chamada¬†`scripts`¬†e adicione um arquivo chamado¬†`getIDs.cdc`:

`import BottomShot from 0xf8d6e0586b0a20c7

pub fun main(acct: Address): [UInt64] {
  let publicRef = getAccount(acct).getCapability(/public/BottomShot2)
            .borrow<&BottomShot.Collection{BottomShot.CollectionPublic}>()
            ?? panic ("Oof ouch owie this account doesn't have a collection there")

  return publicRef.getIDs()
}`

Os scripts s√£o um pouco diferentes das transa√ß√µes. Como eles n√£o exigem assinantes, passamos um endere√ßo ( e n√£o uma conta ) como par√¢metro. Usamos o endere√ßo para obter a conta e depois ligamos para o¬†`getCapability`¬†fun√ß√£o para acessar o recurso que vinculamos anteriormente. Em termos mais simples, estamos acessando o armazenamento p√∫blico de uma conta com seu endere√ßo para chamar uma fun√ß√£o nela.

O¬†`borrow`¬†fun√ß√£o tenta acessar o¬†`CollectionPublic`¬†recurso para que possamos chamar suas fun√ß√µes. Terminamos com p√¢nico, caso as coisas d√™em errado: )

Depois de fazer uma refer√™ncia ao recurso p√∫blico, acabamos de chegar ao¬†`getIDs()`¬†fun√ß√£o.

Para executar isso, volte ao seu terminal ( mantenha o emulador em execu√ß√£o ) e execute este comando:

`# In the FlowNFTs folder
flow scripts execute scripts/getIDs.cdc f8d6e0586b0a20c7`

Isso imprimir√° uma variedade de IDs NFT! Se voc√™ executasse apenas o¬†`depositNFT`¬†transa√ß√£o uma vez, voc√™ ver√°¬†`Result: [1]`. Execute-o algumas vezes mais! Aqui est√° o que vejo depois de duas corridas:

[https://camo.githubusercontent.com/9de72b9a4b253eb6a30b0e881f96062e2ccbfa5b3b4d724bcbfba81b87758dfb/68747470733a2f2f6861636b6d642e696f2f5f75706c6f6164732f424a634b50667146352e706e67](https://camo.githubusercontent.com/9de72b9a4b253eb6a30b0e881f96062e2ccbfa5b3b4d724bcbfba81b87758dfb/68747470733a2f2f6861636b6d642e696f2f5f75706c6f6164732f424a634b50667146352e706e67)

### üö®Relat√≥rio de andamento

Voc√™ fez muito. D√™ um tapinha nas costas. Isso √© dif√≠cil e voc√™ est√° estragando tudo!

Poste uma captura de tela da sa√≠da do script com os IDs em #progress, mostre a todos quanto tempo voc√™ est√°.